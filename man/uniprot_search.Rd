% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/uniprot_search.R
\name{uniprot_search}
\alias{uniprot_search}
\title{Search UniProt via REST API}
\usage{
uniprot_search(
  query,
  database = c("uniprotkb", "uniref", "uniparc", "proteomes", "taxonomy", "keywords",
    "citations", "diseases", "database", "locations", "unirule", "arba"),
  format = c("json", "xml", "txt", "list", "tsv", "fasta", "gff", "obo", "rdf", "xlsx"),
  path = NULL,
  fields = NULL,
  isoform = NULL,
  compressed = FALSE,
  verbosity = NULL,
  dry_run = FALSE
)
}
\arguments{
\item{query}{\code{string}, the search query. See available
\href{https://www.uniprot.org/help/query-fields}{query fields} and help for
\href{https://www.uniprot.org/help/text-search}{constructing queries}.}

\item{database}{\code{string}, the name of the database endpoint of interest.
Choose from: \code{uniprotkb} (default), \code{uniref}, \code{uniparc}, \code{proteomes}, \code{taxonomy},
\code{keywords}, \code{citations}, \code{diseases}, \code{database}, \code{locations}, \code{unirule}, \code{arba}.
See details below.}

\item{format}{\code{string}, desired output format for search results. Different
\code{database} provide different formats, though generally, \code{json} and \code{tsv}
are always available. Choose from: \code{json} (default), \code{xml}, \code{txt}, \code{list}, \code{tsv},
\code{fasta}, \code{gff}, \code{obo}, \code{rdf}, \code{xlsx}.}

\item{path}{Optional \code{string}. Path to save the body of the HTTP response.
This is useful for large search results since it avoids storing the response
in memory.}

\item{fields}{Optional \verb{character vector}. Columns to retrieve in the search
results. Applies to the \code{json}, \code{tsv}, and \code{xlsx} formats only.
See \href{https://www.uniprot.org/help/return_fields}{here} for available
UniProtKB fields}

\item{isoform}{Optional \code{logical}. Whether or not to include isoforms in the
search results. Only applicable if \code{database = "uniprotkb"}.}

\item{compressed}{\code{logical}, should results be returned gzipped? Default is
\code{FALSE}.}

\item{verbosity}{Optional \code{integer}, how much information to print? This is
a wrapper around \code{\link[httr2]{req_verbose}} that uses an integer to
control verbosity:
\itemize{
\item 0: no output.
\item 1: show headers.
\item 2: show headers and bodies.
\item 3: show headers, bodies, and curl status messages.
}}

\item{dry_run}{\code{logical}, default is \code{FALSE}. If \code{TRUE} print the HTTP
request using \code{\link[httr2]{req_dry_run}} without actually sending
anything to the UniProt server. Useful for debugging if you get an HTTP 400
Bad Request error i.e. your \code{query} was not written correctly.}
}
\value{
If the request was successful (i.e. the request was successfully
performed and a response with HTTP status code <400 was received), an HTTP
response is returned; otherwise an error is thrown. Use the \code{path} argument
to save the body of the response to a file.

If \code{dry_run = TRUE}, then prints the HTTP request and returns,
invisibly, a list containing information about the request without actually
sending anything to the UniProt server.
}
\description{
Search UniProt programmatically with \code{\link[httr2:httr2-package]{httr2}}.
Essentially a wrapper around a HTTP \code{\link[httr2]{request}} on the UniProt
REST API sent using \code{\link[httr2]{req_perform}}.
See the
\href{https://www.uniprot.org/help/api_queries}{Retrieving entries via queries}
page for more details on the API this function accesses.
}
\details{
To do: add more details on a number of things!
}
\examples{
# See https://www.uniprot.org/help/query-fields and
# https://www.uniprot.org/help/text-search for help constructing queries.

\dontrun{

# Simple UniProtKB search
resp <- search_uniprot(
  query = "Major capsid protein 723"
)

# Extract the response body (JSON by default)
results <- httr2::resp_body_json(resp)

# Can use paste to construct query string
resp <- search_uniprot(
  query = paste(c("taxonomy_name:candida albicans", "length<50"), collapse = " AND "),
  fields = c("accession", "protein_name", "length")
  format = "tsv"
)

# Extract the response body (tsv this time)
results <- httr2::resp_body_string(resp) \%>\%
  read.delim(text = .)

# To do: add more examples
}

}
