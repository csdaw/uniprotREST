% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fetch_paged.R
\name{fetch_paged}
\alias{fetch_paged}
\title{Fetch results via pagination}
\usage{
fetch_paged(req, n_pages, format = "tsv", path = NULL, verbosity = NULL)
}
\arguments{
\item{req}{\code{httr2_request} object, generated by e.g. \code{\link[httr2:request]{httr2::request()}} or
\code{\link[=uniprot_request]{uniprot_request()}}.}

\item{n_pages}{\code{integer}, the number of pages to be fetched. This can be
calculated by dividing the number of total results by the page size e.g.
\code{resp$headers$x-total-results / page_size}.}

\item{format}{\code{string}, data format to fetch. Can one of \code{"tsv"}, or \code{"fasta"}.}

\item{path}{\code{string} (optional), file path to save the results, e.g.
\code{"path/to/results.tsv"}. The file must not already exist, otherwise an
error is thrown.}

\item{verbosity}{\code{integer} (optional), how much information to print?
\itemize{
\item 0: no output
\item NULL (default): minimal output
\item 1: show request headers
\item 2: show request headers and bodies
\item 3: show request headers, bodies, and curl status messages
}}
}
\value{
By default, returns an object whose type depends on \code{format}:
\itemize{
\item \strong{\code{tsv}}: \code{data.frame}
\item \strong{\code{json}}: \code{list}
\item \strong{\code{fasta}}: \link[Biostrings:XStringSet-class]{Biostrings::AAStringSet} (or \verb{named character} if
Biostrings not installed)
}

If \code{parse = FALSE}, returns an \code{httr2_response}. If \code{path} is specified,
saves the parsed results to the file path indicated, and returns \code{NULL}
invisibly.
}
\description{
This function performs a request for data from the UniProt REST
API, fetches the results using pagination, and saves them to a file or
into memory.

You likely won't use this function directly, but rather one of the
wrapper functions: \code{\link[=uniprot_map]{uniprot_map()}}, \code{\link[=uniprot_search]{uniprot_search()}}, or \code{\link[=uniprot_single]{uniprot_single()}}.
\subsection{Things to note:}{
\enumerate{
\item The pagination endpoint is less expensive for the API infrastructure to
deal with versus \code{\link[=fetch_stream]{fetch_stream()}}, as the memory demand is distributed
over a longer period of time.
\item If the connection is interrupted while fetching results with pagination,
only the request for the current page needs to be reattempted. With the
stream endpoint, the entire request needs to be completely restarted.
}
}
}
\examples{
\dontrun{
  req <- uniprot_request(
    "https://rest.uniprot.org/uniref/search",
    query = "P99999",
    format = "tsv",
    fields = "id,name,count",
    size = 1
  )

  fetch_paged(req, n_pages = 3)
}
}
