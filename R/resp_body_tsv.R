#' Extract tab-delimited data from response body
#'
#' @description This function gets tab-delimited data from an `httr2_response`
#'   and either saves it to a file or parses it into a `data.frame` in memory.
#'
#' @param resp `httr2_response` object, generated by e.g. [httr2::req_perform()] or
#'   [fetch_stream()]/`fetch_paged()`.
#' @param page Optional `integer`, response page number. If `page` > 1 then
#'   the table header is removed before saving to file. Only used when `con` is
#'   specified.
#' @param con Optional `string` or [base::connection] object, the file in which
#'   to save the data.
#' @inheritParams httr2::resp_body_raw
#'
#' @return By default, returns a `data.frame`. If `con` is not NULL, returns
#'   nothing and saves tab-delimited text to the file specified by `con`.
#' @export
#'
#' @examples
#' resp <- structure(
#'   list(method = "GET", url = "https://example.com",
#'        body = charToRaw("Entry\tGene Names (primary)\nP99999\tCYCS\n")),
#'   class = "httr2_response"
#' )
#'
#' resp_body_tsv(resp)
#'
resp_body_tsv <- function(resp, page = NULL, con = NULL, encoding = NULL) {
  check_response(resp)
  if (!is.null(page)) check_integerish(page, lower = 1, max.len = 1)
  # check_con?
  if (!is.null(encoding))
    check_string(encoding)
  else
    encoding <- httr2::resp_encoding(resp)

  if (length(resp$body) == 0) {
    stop("Can not retrieve empty body")
  }

  body <- resp$body %>%
    readBin(character()) %>%
    iconv(from = encoding, to = "UTF-8")

  if (is.null(con)) {
    ## method = "stream" or method = "paged" with path = NULL
    utils::read.delim(text = body)
  } else {
    ## method = "paged" with path = "string"
    if (page == 1L) {
      writeLines(text = body, con = con, sep = "")
    } else {
      # remove header for non-first pages
      writeLines(text = gsub("^.*?\n", "", body), con = con, sep = "")
    }
  }
}
