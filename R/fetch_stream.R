#' Fetch results via stream endpoint
#'
#' @description This function performs a request for data from the UniProt REST
#'   API, fetches the results using the stream endpoint, and saves them to a
#'   file or into memory.
#'
#'   You likely won't use this function directly, but rather one of the
#'   wrapper functions: [uniprot_map()], [uniprot_search()], or [uniprot_single()].
#'
#'   ### Things to note:
#'
#'   1. The stream endpoint is expensive for the API to process. If this endpoint
#'      has too many requests a `429` status error will occur. In this case use
#'      `fetch_paged()` or try `fetch_stream()` again later.
#'   2. Up to 10,000,000 results can be fetched via stream. If you want to get
#'      more results you should use `fetch_paged()`, or consider downloading
#'      some datasets from UniProt's FTP website.
#'
#' @param req `httr2_request` object, generated by e.g. [httr2::request()] or
#'   [uniprot_request()].
#' @param format `string`, data format to fetch. Can only be `"tsv"` at the
#'   moment.
#' @param parse `logical`, should the response body be parsed e.g. into a `data.frame`
#'   or should the `httr2_response` object be returned instead? Default is `TRUE`.
#'   Does nothing if `path` is provided.
#' @param path Optional `string`, file path to save the results, e.g.
#'   `"path/to/results.tsv"`.
#' @inheritParams httr2::req_perform
#'
#' @return By default, returns an object whose type depends on `format`:
#'
#'   - **tsv**: `data.frame`
#'
#'   If `parse = FALSE`, returns an `httr2_response`. If `path` is specified,
#'   saves the parsed results to the file path indicated, and returns `NULL`
#'   invisibly.
#'
#' @export
#'
#' @examples
#' \dontrun{
#'   req <- uniprot_request(
#'     "https://rest.uniprot.org/uniref/stream",
#'     query = "P99999",
#'     format = "tsv",
#'     fields = "id,name,count"
#'   )
#'
#'   fetch_stream(req)
#' }
fetch_stream <- function(req, format = "tsv", parse = TRUE, path = NULL, verbosity = NULL) {
  ## Argument checking
  assert_request(req)
  assert_choice(format, c("tsv"))
  assert_logical(parse, max.len = 1)
  if (!is.null(path)) assert_path_for_output(path)
  if (!is.null(verbosity))
    assert_integerish(verbosity, lower = 0, upper = 3, max.len = 1) # verbosity must be in 0:3

  ## Perform request
  resp <- httr2::req_perform(
    req %>%
      httr2::req_options(
        noprogress = FALSE,
        progressfunction = progress_stream(con = stdout(), verbosity = verbosity)
      ),
    path = path,
    verbosity = verbosity
  )

  if (!is.null(path)) {
    return(invisible)
  } else if (!parse) {
    return(resp)
  } else if (parse) {
    switch(
      format,
      tsv = resp_body_tsv(resp)
    )
  }
}
