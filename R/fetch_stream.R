#' Fetch results via stream endpoint
#'
#' @description This functions performs a request for data from the UniProt REST
#'   API, fetches the results using the stream endpoint, and saves them to a
#'   file or into memory.
#'
#'   You likely won't use this function directly, but rather one of the
#'   wrapper functions: [uniprot_map()], [uniprot_search()], or [uniprot_single()].
#'
#'   ### Stream limitations
#'
#'   1. The stream endpoint is expensive for the API to process. If this endpoint
#'      gas too many requests a `429` status error will occur. In this case use
#'      `fetch_paged()` or try `fetch_stream()` again later.
#'   2. Up to 10,000,000 results can be fetched via stream. If you want to get
#'      more results you should use `fetch_paged()`, or consider downloading
#'      some datasets from UniProt's FTP website.
#'
#' @param req `httr2_request` object, generated by e.g. [httr2::request()] or
#'   [uniprot_request()].
#' @param format `string`, data format to fetch. Can only be `"tsv"` at the
#'   moment.
#' @param parse `logical`, should the response body be parsed e.g. into a `data.frame`
#'   or should the `httr2_response` object be returned instead? Default is `TRUE`.
#'   Does nothing if `path` is provided.
#' @param path Optional `string`, file path to save the results, e.g.
#'   `"path/to/results.tsv"`
#' @param verbosity Optional `integer`, how much information to print? This is
#'   a wrapper around [httr2::req_verbose()] that uses an integer to control
#'   verbosity:
#'
#'   - 0: no output
#'   - 1: show headers
#'   - 2: show headers and bodies
#'   - 3: show headers, bodies, and curl status messages.
#'
#'   Use [httr2::with_verbosity()] to control the verbosity of requests that you
#'   can't affect directly.
#'
#' @return By default, returns an object whose type depends on `format`:
#'
#'   - **tsv**: `data.frame`
#'
#'   If `parse = FALSE`, returns an `httr2_response`. If `path` is specified,
#'   also returns an `httr2_response`, and saves the parsed results to
#'   the file path indicated.
#'
#' @export
#'
#' @examples
#' \dontrun{
#'   req <- request("https://rest.uniprot.org/uniref/UniRef90_P99999.tsv")
#'   fetch_stream(req)
#' }
fetch_stream <- function(req, format = "tsv", parse = TRUE, path = NULL, verbosity = NULL) {
  ## Argument checking
  assert_request(req)
  assert_choice(format, c("tsv"))
  assert_logical(parse, max.len = 1)
  if (!is.null(path)) assert_path_for_output(path)
  if (!is.null(verbosity))
    assert_integerish(verbosity, lower = 0, upper = 3, max.len = 1) # verbosity must be in 0:3

  ## Perform request
  resp <- httr2::req_perform(req, path = path, verbosity = verbosity)

  if (!is.null(path) | !parse) {
    return(resp)
  } else if (parse) {
    switch(
      format,
      tsv = resp_body_tsv(resp)
      # fasta = httr2::resp_body_string(resp) %>% str2fasta(),
      # json = httr2::resp_body_json(resp)
    )
  }
}
